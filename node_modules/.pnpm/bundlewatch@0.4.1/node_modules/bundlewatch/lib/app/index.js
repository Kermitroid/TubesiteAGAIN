"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "STATUSES", {
  enumerable: true,
  get: function () {
    return _analyzeFiles.STATUSES;
  }
});
exports.default = void 0;
var _getLocalFileDetails = _interopRequireDefault(require("./getLocalFileDetails"));
var _BundleWatchService = _interopRequireDefault(require("./reporting/BundleWatchService"));
var _GitHubService = _interopRequireDefault(require("./reporting/GitHubService"));
var _analyze = _interopRequireDefault(require("./analyze"));
var _analyzeFiles = require("./analyze/analyzeFiles");
var _getConfig = _interopRequireDefault(require("./config/getConfig"));
var _createURL = _interopRequireDefault(require("./resultsPage/createURL"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const main = async ({
  files,
  bundlewatchServiceHost,
  ci,
  defaultCompression,
  normalizeFilenames
}) => {
  const currentBranchFileDetails = (0, _getLocalFileDetails.default)({
    files,
    defaultCompression: defaultCompression,
    normalizeFilenames
  });
  const bundlewatchService = new _BundleWatchService.default({
    repoOwner: ci.repoOwner,
    repoName: ci.repoName,
    repoCurrentBranch: ci.repoCurrentBranch,
    repoBranchBase: ci.repoBranchBase,
    commitSha: ci.commitSha,
    bundlewatchServiceHost,
    githubAccessToken: ci.githubAccessToken
  });
  const baseBranchFileDetails = await bundlewatchService.getFileDetailsForBaseBranch();
  await bundlewatchService.saveFileDetailsForCurrentBranch({
    fileDetailsByPath: currentBranchFileDetails,
    trackBranches: ci.trackBranches
  });
  const results = (0, _analyze.default)({
    currentBranchFileDetails,
    baseBranchFileDetails,
    baseBranchName: ci.repoBranchBase
  });
  const url = await (0, _createURL.default)({
    results,
    bundlewatchServiceHost,
    repoOwner: ci.repoOwner,
    repoName: ci.repoName,
    repoCurrentBranch: ci.repoCurrentBranch,
    repoBranchBase: ci.repoBranchBase,
    commitSha: ci.commitSha
  });
  return {
    ...results,
    url
  };
};
const bundlewatchApi = async customConfig => {
  const config = (0, _getConfig.default)(customConfig);
  const githubService = new _GitHubService.default({
    repoOwner: config.ci.repoOwner,
    repoName: config.ci.repoName,
    commitSha: config.ci.commitSha,
    githubAccessToken: config.ci.githubAccessToken
  });
  await githubService.start({
    message: 'Checking bundlewatch...'
  });
  try {
    const results = await main(config);
    if (results.status === _analyzeFiles.STATUSES.FAIL) {
      await githubService.fail({
        message: results.summary,
        url: results.url
      });
      await Promise.all(results.fullResults.map(result => {
        if (result.status === _analyzeFiles.STATUSES.FAIL) {
          return githubService.fail({
            message: result.message,
            filePath: result.filePath
          });
        }
        return Promise.resolve();
      }));
    } else {
      // TODO: add warn
      await githubService.pass({
        message: results.summary,
        url: results.url
      });
    }
    return results;
  } catch (e) {
    await githubService.error({
      message: `Unable to analyze, check logs. ${e ? e.message : ''}`
    });
    throw e;
  }
};
var _default = exports.default = bundlewatchApi;