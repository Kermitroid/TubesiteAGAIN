"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpRequestFactory = void 0;
const http_1 = require("http");
const https_1 = require("https");
const url_1 = require("url");
const UrlAccessorResolver_1 = require("./urlAccessor/UrlAccessorResolver");
class HttpRequestFactory {
    constructor(timeout = 30000) {
        this.timeout = timeout;
    }
    createRequest(request) {
        let urlAccessor = UrlAccessorResolver_1.UrlAccessorResolver.getUrlAccessor(request);
        let urlString = urlAccessor.getUrlFromRequest(request);
        return new Promise((resolve, reject) => {
            let url = new url_1.URL(urlString);
            let headers = {};
            Object.assign(headers, request.headers());
            let options = {
                protocol: url.protocol,
                method: request.method(),
                hostname: url.hostname,
                port: url.port,
                path: url.pathname + url.search,
                headers: headers
            };
            let timeout;
            let requestInterface = url.protocol === 'https:' ? https_1.request : http_1.request;
            let req = requestInterface(options, (res) => {
                let chunks = [];
                res.on('data', (chunk) => {
                    chunks.push(chunk);
                });
                res.on('end', () => {
                    let body = Buffer.concat(chunks);
                    clearTimeout(timeout);
                    resolve({
                        body: body.toString(),
                        contentType: res.headers['content-type'],
                        status: res.statusCode,
                        headers: Object
                            .keys(res.headers)
                            .reduce(this.convertHeaders.bind(this, res.headers), {})
                    });
                });
            });
            timeout = setTimeout(() => {
                req.end();
                reject(new Error(`unable to load: ${url}. request timed out after ${this.timeout / 1000} seconds.`));
            }, this.timeout);
            req.end();
        });
    }
    convertHeaders(responseHeaders, prev, key) {
        let currentHeader = responseHeaders[key];
        if (typeof currentHeader === 'string') {
            prev[key] = currentHeader;
        }
        else if (Array.isArray(currentHeader)) {
            prev[key] = currentHeader.join(', ');
        }
        else {
            prev[key] = '';
        }
        return prev;
    }
}
exports.HttpRequestFactory = HttpRequestFactory;
