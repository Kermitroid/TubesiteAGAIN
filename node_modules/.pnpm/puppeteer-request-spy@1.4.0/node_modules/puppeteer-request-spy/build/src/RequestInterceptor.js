"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestInterceptor = void 0;
const instanceOfRequestBlocker_1 = require("./common/interfaceValidators/instanceOfRequestBlocker");
const instanceOfRequestModifier_1 = require("./common/interfaceValidators/instanceOfRequestModifier");
const instanceOfRequestSpy_1 = require("./common/interfaceValidators/instanceOfRequestSpy");
const instanceOfResponseFaker_1 = require("./common/interfaceValidators/instanceOfResponseFaker");
const resolveOptionalPromise_1 = require("./common/resolveOptionalPromise");
const UrlAccessorResolver_1 = require("./common/urlAccessor/UrlAccessorResolver");
const VoidLogger_1 = require("./common/VoidLogger");
const RequestBlocker_1 = require("./RequestBlocker");
class RequestInterceptor {
    constructor(matcher, logger) {
        this.requestSpies = [];
        this.responseFakers = [];
        this.requestModifiers = [];
        if (typeof logger === 'undefined') {
            logger = new VoidLogger_1.VoidLogger();
        }
        this.logger = logger;
        this.matcher = matcher;
        this.requestBlocker = new RequestBlocker_1.RequestBlocker();
    }
    intercept(interceptedRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.matchSpies(interceptedRequest);
            if (yield resolveOptionalPromise_1.resolveOptionalPromise(this.requestBlocker.shouldBlockRequest(interceptedRequest, this.matcher))) {
                yield this.blockUrl(interceptedRequest);
                return;
            }
            let requestOverride = yield this.getMatchingOverride(interceptedRequest);
            if (typeof requestOverride !== 'undefined') {
                let urlAccessor = UrlAccessorResolver_1.UrlAccessorResolver.getUrlAccessor(interceptedRequest);
                yield interceptedRequest.continue(requestOverride);
                this.logger.log(`modified: ${urlAccessor.getUrlFromRequest(interceptedRequest)}`);
                return;
            }
            let responseFaker = yield this.getMatchingFaker(interceptedRequest);
            if (typeof responseFaker !== 'undefined') {
                let responseFake = responseFaker.getResponseFake(interceptedRequest);
                yield interceptedRequest.respond(yield resolveOptionalPromise_1.resolveOptionalPromise(responseFake));
                this.logger.log(`faked: ${interceptedRequest.url()}`);
                return;
            }
            yield this.acceptUrl(interceptedRequest);
        });
    }
    addSpy(requestSpy) {
        if (!instanceOfRequestSpy_1.instanceOfRequestSpy(requestSpy)) {
            throw new Error('invalid RequestSpy provided. Please make sure to match the interface provided.');
        }
        this.requestSpies.push(requestSpy);
    }
    addFaker(responseFaker) {
        if (!instanceOfResponseFaker_1.instanceOfResponseFaker(responseFaker)) {
            throw new Error('invalid ResponseFaker provided. Please make sure to match the interface provided.');
        }
        this.responseFakers.push(responseFaker);
    }
    addRequestModifier(requestModifier) {
        if (!instanceOfRequestModifier_1.instanceOfRequestModifier(requestModifier)) {
            throw new Error('invalid RequestModifier provided. Please make sure to match the interface provided.');
        }
        this.requestModifiers.push(requestModifier);
    }
    block(urlsToBlock) {
        this.requestBlocker.addUrlsToBlock(urlsToBlock);
    }
    clearSpies() {
        this.requestSpies = [];
    }
    clearFakers() {
        this.responseFakers = [];
    }
    clearRequestModifiers() {
        this.requestModifiers = [];
    }
    clearUrlsToBlock() {
        this.requestBlocker.clearUrlsToBlock();
    }
    setUrlsToBlock(urlsToBlock) {
        this.requestBlocker.clearUrlsToBlock();
        this.requestBlocker.addUrlsToBlock(urlsToBlock);
    }
    setRequestBlocker(requestBlocker) {
        if (!instanceOfRequestBlocker_1.instanceOfRequestBlocker(requestBlocker)) {
            throw new Error('invalid RequestBlocker provided. Please make sure to match the interface provided.');
        }
        this.requestBlocker = requestBlocker;
    }
    getMatchingFaker(interceptedRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let faker of this.responseFakers) {
                if (yield resolveOptionalPromise_1.resolveOptionalPromise(faker.isMatchingRequest(interceptedRequest, this.matcher))) {
                    return faker;
                }
            }
            return undefined;
        });
    }
    matchSpies(interceptedRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let spy of this.requestSpies) {
                if (yield resolveOptionalPromise_1.resolveOptionalPromise(spy.isMatchingRequest(interceptedRequest, this.matcher))) {
                    yield resolveOptionalPromise_1.resolveOptionalPromise(spy.addMatch(interceptedRequest));
                }
            }
        });
    }
    getMatchingOverride(interceptedRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestOverride;
            for (let requestModifier of this.requestModifiers) {
                if (yield resolveOptionalPromise_1.resolveOptionalPromise(requestModifier.isMatchingRequest(interceptedRequest, this.matcher))) {
                    requestOverride = yield resolveOptionalPromise_1.resolveOptionalPromise(requestModifier.getOverride(interceptedRequest));
                }
            }
            return requestOverride;
        });
    }
    blockUrl(interceptedRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            let urlAccessor = UrlAccessorResolver_1.UrlAccessorResolver.getUrlAccessor(interceptedRequest);
            try {
                yield interceptedRequest.abort();
                this.logger.log(`aborted: ${urlAccessor.getUrlFromRequest(interceptedRequest)}`);
            }
            catch (error) {
                this.logger.log(error.toString());
            }
        });
    }
    acceptUrl(interceptedRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            let urlAccessor = UrlAccessorResolver_1.UrlAccessorResolver.getUrlAccessor(interceptedRequest);
            try {
                yield interceptedRequest.continue();
                this.logger.log(`loaded: ${urlAccessor.getUrlFromRequest(interceptedRequest)}`);
            }
            catch (error) {
                this.logger.log(error.toString());
            }
        });
    }
}
exports.RequestInterceptor = RequestInterceptor;
