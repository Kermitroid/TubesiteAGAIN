class PlayerSdk {
    constructor(targetSelector, userOptions) {
        this.iframe = null;
        this.sdkInSync = false;
        this.currentVideoReady = false;
        this.onceSdkInSyncCallbacks = [];
        this.onceVideoReadyCallbacks = [];
        this.userEventListeners = [];
        this.playerOrigin = null;
        this.postMessageCallbacks = {};
        this.appendQueryParamIfMissing = (url, name, value) => {
            const urlObj = new URL(url, document.location.href);
            const urlSearchParams = new URLSearchParams(urlObj.search);
            if (urlSearchParams.has(name)) {
                return url;
            }
            urlSearchParams.append(name, value);
            urlObj.search = urlSearchParams.toString();
            return urlObj.toString();
        };
        this.sdkPlayerId = PlayerSdk.nextSdkPlayerId++;
        this.sdkOrigin = `${window.location.protocol}//${window.location.host}`;
        const target = targetSelector instanceof Element
            ? targetSelector
            : document.querySelector(targetSelector);
        if (target == null) {
            throw new Error("No match found for selector " + targetSelector);
        }
        this.iframe =
            target.tagName !== "IFRAME"
                ? this.createIframe(target)
                : target;
        const options = userOptions || {};
        this.iframeUrl = this.getIframeUrl(options);
        if (!this.iframe.src) {
            this.createNewPlayer(this.iframe, options);
        }
        else {
            this.bindExistingPlayer(this.iframe);
        }
        this.onceSdkInSyncCallbacks = [];
        this.userEventListeners = [];
        this.sdkInSync = false;
        this.currentVideoReady = false;
        this.playerOrigin = new URL(this.iframeUrl).origin;
        this.options = options;
        window.addEventListener("message", (message) => {
            var _a;
            if (message.origin === this.playerOrigin &&
                parseInt((_a = message.data) === null || _a === void 0 ? void 0 : _a.sdkPlayerId, 10) === this.sdkPlayerId) {
                if (!!message.data.callbackId &&
                    !!this.postMessageCallbacks[message.data.callbackId]) {
                    this.postMessageCallbacks[message.data.callbackId](message.data.arg);
                }
                else {
                    this.onEvent(message.data);
                }
            }
        }, false);
        if (options.playbackRate) {
            this.setPlaybackRate(options.playbackRate);
        }
    }
    getIframeUrl(options) {
        if (options.iframeUrl) {
            return options.iframeUrl;
        }
        const domain = options.customDomain || "embed.api.video";
        return "https://" + domain + "/${type}/${id}";
    }
    loadConfig(options) {
        this.currentVideoReady = false;
        this.options = Object.assign(Object.assign({}, this.options), options);
        this.postMessage({
            message: "loadConfig",
            url: this.buildPlayerUrl(this.options),
        });
    }
    play() {
        this.postMessage({ message: "play" });
    }
    setVideoStyleTransform(value) {
        this.postMessage({
            message: "setStyleProperty",
            query: "video",
            property: "transform",
            value,
        }, undefined, false);
        this.postMessage({
            message: "setStyleProperty",
            query: ".vjs-poster",
            property: "transform",
            value,
        }, undefined, false);
    }
    setVideoStyleObjectFit(value) {
        this.postMessage({
            message: "setStyleProperty",
            query: "video",
            property: "object-fit",
            value,
        }, undefined, false);
        this.postMessage({
            message: "setStyleProperty",
            query: ".vjs-poster",
            property: "background-size",
            value: value !== "fill" ? value : "100% 100%",
        }, undefined, false);
    }
    // This feature is experimental.
    // It may change or be removed at any time and could cause significant playback issues.
    setMinimalQuality(quality) {
        this.postMessage({ message: "setMinimalQuality", quality });
    }
    // This feature is experimental.
    // It may change or be removed at any time and could cause significant playback issues.
    setMaximalQuality(quality) {
        this.postMessage({ message: "setMaximalQuality", quality });
    }
    hideControls(controls) {
        if (!controls) {
            this.options.hideControls = true;
        }
        this.postMessage({ message: "hideControls", controls }, undefined, true);
    }
    showControls(controls) {
        if (!controls) {
            this.options.hideControls = false;
        }
        this.postMessage({ message: "showControls", controls }, undefined, true);
    }
    hideSubtitles() {
        this.options.showSubtitles = false;
        this.postMessage({ message: "hideSubtitles" });
    }
    showSubtitles() {
        this.options.showSubtitles = true;
        this.postMessage({ message: "showSubtitles" });
    }
    hideTitle() {
        this.options.hideTitle = true;
        this.postMessage({ message: "hideTitle" });
    }
    showTitle() {
        this.options.hideTitle = false;
        this.postMessage({ message: "showTitle" });
    }
    hidePoster() {
        this.options.hidePoster = true;
        this.postMessage({ message: "hidePoster" });
    }
    showPoster() {
        this.options.hidePoster = false;
        this.postMessage({ message: "showPoster" });
    }
    pause() {
        this.postMessage({ message: "pause" });
    }
    mute() {
        this.options.muted = true;
        this.postMessage({ message: "mute" });
    }
    unmute() {
        this.options.muted = false;
        this.postMessage({ message: "unmute" });
    }
    seek(time) {
        this.postMessage({ message: "seek", seek: time });
    }
    setCurrentTime(time) {
        this.postMessage({ message: "setCurrentTime", currentTime: time });
    }
    setVolume(volume) {
        this.postMessage({ message: "setVolume", volume });
    }
    setAutoplay(autoplay) {
        this.options.autoplay = autoplay;
        this.postMessage({ message: "setAutoplay", autoplay });
    }
    setLoop(loop) {
        this.options.loop = loop;
        this.postMessage({ message: "setLoop", loop });
    }
    setChromeless(chromeless) {
        this.options.chromeless = chromeless;
        this.postMessage({ message: "setChromeless", chromeless });
    }
    setPlaybackRate(rate) {
        this.options.playbackRate = rate;
        this.postMessage({ message: "setPlaybackRate", rate }, undefined, true);
    }
    exitFullscreen() {
        this.postMessage({ message: "exitFullscreen" }, undefined, true);
    }
    requestFullscreen() {
        this.postMessage({ message: "requestFullscreen" }, undefined, true);
    }
    exitPictureInPicture() {
        this.postMessage({ message: "exitPictureInPicture" }, undefined, true);
    }
    requestPictureInPicture() {
        this.postMessage({ message: "requestPictureInPicture" }, undefined, true);
    }
    setTheme(theme) {
        this.postMessage({ message: "setTheme", theme });
    }
    getPaused(callback) {
        return this.postMessage({ message: "getPaused" }, callback);
    }
    getMuted(callback) {
        return this.postMessage({ message: "getMuted" }, callback);
    }
    getPlaying(callback) {
        return this.postMessage({ message: "getPlaying" }, callback);
    }
    getDuration(callback) {
        return this.postMessage({ message: "getDuration" }, callback, true);
    }
    getCurrentTime(callback) {
        return this.postMessage({ message: "getCurrentTime" }, callback);
    }
    getPlaybackRate(callback) {
        return this.postMessage({ message: "getPlaybackRate" }, callback);
    }
    getVolume(callback) {
        return this.postMessage({ message: "getVolume" }, callback);
    }
    getLoop(callback) {
        return this.postMessage({ message: "getLoop" }, callback);
    }
    download(filename) {
        this.postMessage({ message: "getMp4Url" }, (res) => {
            if (!res) {
                throw new Error("This video is not downloadable");
            }
            fetch(res).then((response) => {
                response.blob().then((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement("a");
                    link.href = url;
                    link.download = filename || "video.mp4";
                    link.target = "_blank";
                    link.click();
                    URL.revokeObjectURL(url);
                });
            });
        });
    }
    getVideoSize(callback) {
        return this.postMessage({ message: "getVideoSize" }, callback, true);
    }
    isLiveStream(callback) {
        return this.postMessage({ message: "isLiveStream" }, callback);
    }
    addEventListener(event, callback) {
        this.userEventListeners.push({ event, callback });
    }
    destroy() {
        this.postMessage({ message: "destroy" });
        setTimeout(() => { var _a, _b; return (_b = (_a = this.iframe) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(this.iframe); }, 0);
    }
    createNewPlayer(iframe, options) {
        this.setIframeSrc(iframe, this.buildPlayerUrl(options));
    }
    buildPlayerUrl(options) {
        if (!options.id) {
            throw new Error("Missing id in options");
        }
        const url = this.iframeUrl
            .replace("${id}", options.id)
            .replace("${type}", options.live ? "live" : "vod");
        return this.addParametersInIframeHash(`${url}?${this.urlParametersFromOptions(options)}`, options);
    }
    bindExistingPlayer(iframe) {
        this.setIframeSrc(iframe, this.addParametersInIframeHash(iframe.src, {}));
    }
    addParametersInIframeHash(url, options) {
        var _a, _b, _c, _d, _e, _f;
        const addParameterInIframeHash = (parameter, value) => {
            const indexOfHash = url.indexOf("#");
            const parameterAndValue = value ? `${parameter}:${value}` : parameter;
            if (indexOfHash === -1) {
                return `${url}#${parameterAndValue}`;
            }
            const beforeHash = url.substr(0, indexOfHash);
            let afterHash = url.substr(indexOfHash + 1);
            afterHash = afterHash.replace(new RegExp(`${parameter}(:[^;]+)?;?`), "");
            return `${beforeHash}#${parameterAndValue};${afterHash}`;
        };
        url = addParameterInIframeHash("sdkPlayerId", "" + this.sdkPlayerId);
        url = addParameterInIframeHash("sdkOrigin", btoa(this.sdkOrigin));
        url = addParameterInIframeHash("api");
        if (options.hideControls === true) {
            url = addParameterInIframeHash("hide-controls");
        }
        if (options.hotKeys !== undefined && !options.hotKeys) {
            url = addParameterInIframeHash("hotkeys:false");
        }
        if (options.chromeless === true) {
            url = addParameterInIframeHash("chromeless");
        }
        if (options.hidePoster === true) {
            url = addParameterInIframeHash("hide-poster");
        }
        if (options.loop === true) {
            url = addParameterInIframeHash("loop");
        }
        if (options.hideTitle === true) {
            url = addParameterInIframeHash("hide-title");
        }
        if (options.showSubtitles === true) {
            url = addParameterInIframeHash("show-subtitles");
        }
        if (options.minimalQuality !== undefined) {
            url = addParameterInIframeHash(`min-quality:${encodeURIComponent(options.minimalQuality)}`);
        }
        if (options.maximalQuality !== undefined) {
            url = addParameterInIframeHash(`max-quality:${encodeURIComponent(options.maximalQuality)}`);
        }
        if ((_a = options.ads) === null || _a === void 0 ? void 0 : _a.adTagUrl) {
            url = addParameterInIframeHash(`adTagUrl:${encodeURIComponent((_b = options.ads) === null || _b === void 0 ? void 0 : _b.adTagUrl)}`);
        }
        if (!isNaN(parseInt("" + ((_c = options.sequence) === null || _c === void 0 ? void 0 : _c.end), 10)) &&
            !isNaN(parseInt("" + ((_d = options.sequence) === null || _d === void 0 ? void 0 : _d.start), 10))) {
            url = addParameterInIframeHash(`t=${(_e = options.sequence) === null || _e === void 0 ? void 0 : _e.start},${(_f = options.sequence) === null || _f === void 0 ? void 0 : _f.end}`);
        }
        return url;
    }
    urlParametersFromOptions(options) {
        const allowedKeys = [
            "id",
            "live",
            "autoplay",
            "muted",
            "metadata",
            "hideControls",
            "hidePoster",
            "chromeless",
            "loop",
            "hideTitle",
            "iframeUrl",
            "token",
            "showSubtitles",
            "ts",
            "avh",
        ];
        const optionsAsAny = options;
        optionsAsAny.ts = new Date().getTime();
        if (options.privateSession) {
            optionsAsAny.avh = options.privateSession;
        }
        return Object.keys(options)
            .map((key) => {
            if (allowedKeys.indexOf(key) === -1) {
                return;
            }
            if (key === "metadata" && typeof optionsAsAny[key] === "object") {
                const metadata = optionsAsAny[key];
                return Object.keys(metadata)
                    .map((metadataName) => {
                    return "metadata[" + metadataName + "]=" + metadata[metadataName];
                })
                    .join("&");
            }
            return key + "=" + optionsAsAny[key];
        })
            .join("&");
    }
    onEvent(data) {
        const userData = Object.assign({}, data);
        delete userData.type;
        delete userData.sdkPlayerId;
        this.userEventListeners
            .filter((uel) => uel.event === data.type)
            .forEach((uel) => uel.callback(userData));
        switch (data.type) {
            case "ready":
                this.onVideoReady();
                break;
            case "sdkSync":
                this.onSdkInSync();
                break;
        }
    }
    onSdkInSync() {
        if (!this.sdkInSync) {
            this.sdkInSync = true;
            this.onceSdkInSyncCallbacks.forEach((cb) => {
                cb();
            });
        }
    }
    onVideoReady() {
        if (!this.currentVideoReady) {
            this.currentVideoReady = true;
            this.onceVideoReadyCallbacks.forEach((cb) => {
                cb();
            });
        }
    }
    postMessage(message, callback, requireVideoReady = false) {
        return new Promise((resolve, reject) => {
            var _a;
            if (!this.playerOrigin || !((_a = this.iframe) === null || _a === void 0 ? void 0 : _a.contentWindow)) {
                reject();
                return;
            }
            const messageWithPlayerId = Object.assign(Object.assign({}, message), { sdkPlayerId: this.sdkPlayerId });
            const callbackId = this.makeId(16);
            this.postMessageCallbacks[callbackId] = (res) => {
                resolve(res);
                if (!!callback) {
                    callback(res);
                }
            };
            messageWithPlayerId.callbackId = callbackId;
            if (!this.currentVideoReady && requireVideoReady) {
                this.onceVideoReadyCallbacks.push(() => {
                    var _a, _b;
                    return this.playerOrigin &&
                        ((_b = (_a = this.iframe) === null || _a === void 0 ? void 0 : _a.contentWindow) === null || _b === void 0 ? void 0 : _b.postMessage(messageWithPlayerId, this.playerOrigin));
                });
                return;
            }
            if (this.sdkInSync && !!this.playerOrigin) {
                this.iframe.contentWindow.postMessage(messageWithPlayerId, this.playerOrigin);
                return;
            }
            this.onceSdkInSyncCallbacks.push(() => {
                var _a, _b;
                return this.playerOrigin &&
                    ((_b = (_a = this.iframe) === null || _a === void 0 ? void 0 : _a.contentWindow) === null || _b === void 0 ? void 0 : _b.postMessage(messageWithPlayerId, this.playerOrigin));
            });
        });
    }
    makeId(length) {
        const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        const charactersLength = characters.length;
        let result = "";
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    }
    createIframe(target) {
        const ifr = document.createElement("iframe");
        ifr.style.height = "100%";
        ifr.style.width = "100%";
        ifr.allowFullscreen = true;
        ifr.allow = "autoplay";
        target.appendChild(ifr);
        return ifr;
    }
    setIframeSrc(iframe, url) {
        iframe.src = url;
    }
}
PlayerSdk.nextSdkPlayerId = 1;

export { PlayerSdk };
//# sourceMappingURL=index.es.js.map
